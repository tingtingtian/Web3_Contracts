SimpleAMM一个简单的自动做市商（AMM）合约，并防止重入攻击。该合约实现了 Checks-Effects-Interactions 模式和重入锁（reentrancy guard）来确保安全性。
代码说明：
    1.	重入保护：通过引入 ReentrancyGuard，在每个函数中使用 nonReentrant 修饰符，确保函数在执行时不会被重新进入，从而避免重入攻击。
	2.	Checks-Effects-Interactions 模式：
	    •在 removeLiquidity 和 swap 函数中，先检查输入金额和储备情况，满足条件后立即更新储备量，然后才进行外部调用（代币转账）。这种模式可以避免在外部调用过程中出现不一致的状态。
	3.	流动性管理：addLiquidity 和 removeLiquidity 函数用于管理流动性，确保用户能够为池子添加或移除代币，同时更新合约的储备量。
	4.	交易逻辑：swapAtoB 和 swapBtoA 函数采用固定乘积公式（x * y = k）计算兑换比例，并收取 0.3% 的交易手续费。


AMMPool自动做市商（AMM）合约示例，模拟了 Uniswap V2 的一些核心机制。该合约实现了以下功能：
	1.	恒定乘积公式：使用  x * y = k  的公式来保持流动性池的平衡。
	2.	流动性代币：流动性提供者将获得流动性代币（LP Tokens），代表他们在池中的份额。
	3.	交易手续费：每次交易收取 0.3% 的手续费，奖励给流动性提供者。
	4.	滑点保护：在交易时，允许用户设置最小/最大兑换量，防止滑点。
	5.	流动性增减：提供了流动性添加和移除的功能，并保证在移除流动性时按比例退还代币。

代码说明：
    1.	流动性代币 (LP Token)：
        •	该合约继承 ERC20，因此实现了 LP Token 的铸造和销毁。
        •	每当用户添加流动性时，会按照池中代币的比例分配 LP Token，代表用户在池中的份额。
	2.	添加流动性 (addLiquidity)：
        •	若首次添加流动性，根据用户输入量的乘积计算流动性代币。
        •	非首次添加流动性时，根据当前池子的比例来分配 LP Token。
	    •	使用 sqrt 和 min 函数辅助流动性计算，保证精确性。
	3.	移除流动性 (removeLiquidity)：
        •	按比例返还用户提供的代币量。
        •	销毁用户的 LP Token，并按比例从池中扣除相应的储备量。
	4.	代币交换 (swapAtoB 和 swapBtoA)：
        •	采用常用的恒定乘积公式  x \times y = k  进行兑换计算。
        •	每笔交易收取 0.3% 的手续费，直接进入流动性池，奖励流动性提供者。
        •	用户可以设置最小兑换量 minAmountBOut 或 minAmountAOut，避免滑点风险。
	5.	储备更新和滑点保护：
        •	在每次流动性添加、移除和交易后，更新 reserveA 和 reserveB 以确保池内状态一致性。
        •	滑点保护机制确保用户兑换的最低金额，避免用户在不利市场条件下过度损失。